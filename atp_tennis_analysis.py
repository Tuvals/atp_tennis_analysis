# -*- coding: utf-8 -*-
"""Tennis matches analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-TIoVGkvdhp62tHp1vXPWQk4M1bV3qGr
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

# %matplotlib inline

def csv_drive_path_generatoer(url):
 '''
 Help in read csv file directly from google drive.
 Make sure the csv format is standard.
 url:str - path to csv file example:
   url = 'https://drive.google.com/file/d/126JPZ3lYwdLyJ2d_7jxM9jMtZaOlF-Ld/view?usp=sharing'
 return : str
 '''
 path = 'https://drive.google.com/uc?export=download&id='+url.split('/')[-2]
 return path

# 2011-2015
url_pbp_matches_atp_main_archive = 'https://drive.google.com/file/d/1PgmKOjlyCHxH97WXRbHmYktSkEB2RO0p/view?usp=sharing'
# 2015-2017
url_pbp_matches_atp_main_current = 'https://drive.google.com/file/d/1hgHbkW1Tnj59HKDmrJFW4UyqOq8A1PvN/view?usp=sharing'

data_pbp_matches_atp_main_archive = csv_drive_path_generatoer(url_pbp_matches_atp_main_archive)
data_pbp_matches_atp_main_current = csv_drive_path_generatoer(url_pbp_matches_atp_main_current)


df_pbp_matches_atp_main_archive = pd.read_csv(data_pbp_matches_atp_main_archive, header=int(), squeeze=True)
df_pbp_matches_atp_main_current = pd.read_csv(data_pbp_matches_atp_main_current, header=int(), squeeze=True)

# concatenate two df into ine
df_pbp_matches_atp_main_11_17 = pd.concat([df_pbp_matches_atp_main_archive, df_pbp_matches_atp_main_current])


# cutting off unwanted columns
del df_pbp_matches_atp_main_11_17['pbp_id']
del df_pbp_matches_atp_main_11_17['tny_name']
del df_pbp_matches_atp_main_11_17['tour']
del df_pbp_matches_atp_main_11_17['draw']
del df_pbp_matches_atp_main_11_17['date']
del df_pbp_matches_atp_main_11_17['wh_minutes']

# convert 'winner' to string
df_pbp_matches_atp_main_11_17['winner'] = df_pbp_matches_atp_main_11_17['winner'].apply(str)

# convert 'pbp' to string
df_pbp_matches_atp_main_11_17['pbp'] = df_pbp_matches_atp_main_11_17['pbp'].str.split('.')

# reset index
df_pbp_matches_atp_main_11_17.reset_index()

# split "pbp" into 6 columns
df_pbp_matches_atp_main_11_17_sets = pd.DataFrame(df_pbp_matches_atp_main_11_17["pbp"].to_list(), columns=['set_1', 'set_2', 'set_3', 'set_4', 'set_5', 'set_6'])


df_pbp_matches_atp_main_11_17_sets['set_1'] = df_pbp_matches_atp_main_11_17_sets['set_1'].str.split(';')
df_pbp_matches_atp_main_11_17_sets['set_2'] = df_pbp_matches_atp_main_11_17_sets['set_2'].str.split(';')
df_pbp_matches_atp_main_11_17_sets['set_3'] = df_pbp_matches_atp_main_11_17_sets['set_3'].str.split(';')
df_pbp_matches_atp_main_11_17_sets['set_4'] = df_pbp_matches_atp_main_11_17_sets['set_4'].str.split(';')
df_pbp_matches_atp_main_11_17_sets['set_5'] = df_pbp_matches_atp_main_11_17_sets['set_5'].str.split(';')
df_pbp_matches_atp_main_11_17_sets['set_6'] = df_pbp_matches_atp_main_11_17_sets['set_6'].str.split(';')

# df_pbp_matches_atp_main_11_17_sets


# join 6 columns into data frame
df = df_pbp_matches_atp_main_11_17.join(df_pbp_matches_atp_main_11_17_sets)





def replace_points(sets):
  def f(game, i):
    if i%2==0:
      return game.replace('S', '1').replace('R', '2').replace('A', '1').replace('D', '2')
    else:
      return game.replace('S', '2').replace('R', '1').replace('A', '2').replace('D', '1')
  return [f(game, i) for i, game in enumerate(sets)]




df['set_1'] = df.apply({'set_1':replace_points})
df['set_2'] = df.apply({'set_2':replace_points})
df['set_3'] = df['set_3'].map(lambda x: replace_points(x) if type(x) == list else x)
df['set_4'] = df['set_4'].map(lambda x: replace_points(x) if type(x) == list else x)
df['set_5'] = df['set_5'].map(lambda x: replace_points(x) if type(x) == list else x)
df['set_6'] = df['set_6'].map(lambda x: replace_points(x) if type(x) == list else x)

# servs:
# join list items into one string
df['servs_qty'] = [','.join(map(str, l)) for l in df['pbp']]
df['servs_qty'] = df['servs_qty'].str.replace(',', '')
df['servs_qty'] = df['servs_qty'].str.replace('.', '')
df['servs_qty'] = df['servs_qty'].str.len()

#########################################################################
df['server1_won'] = df['winner'].str.count("1")
df['server1_lost'] = df['winner'].str.count("2")

#########################################################################
# games:
df['games_qty'] = [','.join(map(str, l)) for l in df['pbp']]

# count 'pbp' list items as 'count_games'
df['games_qty'] = df['games_qty'].str.split(';').str.len()


# sets:
df['score'] = df['score'].str.split()

# count 'score' list items as 'count_sets'
df['sets_qty'] = df['score'].str.len()

# set 1 server won qty
df['set_1_string'] = [','.join(map(str, l)) for l in df['set_1']]

df['set_1_server_won_qty'] = df['set_1_string'].str.count("1")

# first game, set 1 server won qty
df.loc[:, 'set_1_first_game_server_won_qty'] = df['set_1'].map(lambda x: x[0]).str.count("1")

# first game, set 1 server lost qty
df.loc[:, 'set_1_first_game_server_lost_qty'] = df['set_1'].map(lambda x: x[0]).str.count("2")

del df['set_1']
del df['set_1_string']

################################################################################
# set 2 server won qty
df['set_2_string'] = [','.join(map(str, l)) for l in df['set_2']]

df['set_2_server_won_qty'] = df['set_2_string'].str.count("1")

# first game, set 2 server won qty
df.loc[:, 'set_2_first_game_server_won_qty'] = df['set_2'].map(lambda x: x[0]).str.count("1")

del df['set_2']
del df['set_2_string']

################################################################################
# set 3 server won qty
df['set_3_server_won_qty'] = df['set_3'].map('{}'.format, na_action='ignore').str.count("1")

# first game, set 3 server won qty
df.loc[:, 'set_3_first_game_server_won_qty'] = df['set_3'].map(lambda x: x[0] if type(x) == list else x).str.count("1")

del df['set_3']

################################################################################
# set 4 server won qty
df['set_4_server_won_qty'] = df['set_4'].map('{}'.format, na_action='ignore').str.count("1")

# first game, set 4 server won qty
df.loc[:, 'set_4_first_game_server_won_qty'] = df['set_4'].map(lambda x: x[0] if type(x) == list else x).str.count("1")

del df['set_4']

################################################################################
# set 5 server won qty
df['set_5_server_won_qty'] = df['set_5'].map('{}'.format, na_action='ignore').str.count("1")

# first game, set 5 server won qty
df.loc[:, 'set_5_first_game_server_won_qty'] = df['set_5'].map(lambda x: x[0] if type(x) == list else x).str.count("1")

del df['set_5']

################################################################################
# set 6 server won qty
# df['set_6_server_won_qty'] = df['set_6'].map('{}'.format, na_action='ignore').str.count("1")

# first game, set 6 server won qty
# df.loc[:, 'set_6_first_game_server_won_qty'] = df['set_6'].map(lambda x: x[0] if type(x) == list else x).str.count("1")

del df['set_6']

# cleaning 

del df['adf_flag']

del df['server1']
del df['server2']

df = df.reset_index()

del df['index']

# server advantage percent

df['string_servs'] = [','.join(map(str, l)) for l in df['pbp']]

df['server_ace_qty'] = df['string_servs'].str.count("A")
df['server_won_qty'] = df['string_servs'].str.count("S")
df['server_lost_qty'] = df['string_servs'].str.count("R")
df['server_df_qty'] = df['string_servs'].str.count("D")


# df['server_won_percent'] = df['server_won_qty'] / df['servs_qty']
# df['server_won_percent_format'] = pd.Series(["{0:.2f}%".format(val * 100) for val in df['server_won_percent']], index = df.index)
# del df['server_won_percent']



servs_qty = df['servs_qty'].sum()
server_won_qty = df['server_ace_qty'].sum() + df['server_won_qty'].sum()


server_advantage = server_won_qty / servs_qty
server_advantage

# P(A/B)
# P(A) = win a match | server1_won / total_first_game
# P(B) = first game won | first_game_won_qty / total_first_game

server1_won = df['server1_won'].sum()
total_matches = 13050
A = server1_won / total_matches

server1_first_game_won_qty = df['set_1_first_game_server_won_qty'].sum()
server1_first_game_lost_qty = df['set_1_first_game_server_lost_qty'].sum()
df['server1_first_game_won'] = df['set_1_first_game_server_won_qty'] > df['set_1_first_game_server_lost_qty']

first_game_won_qty = df['server1_first_game_won'].sum()
B = first_game_won_qty / total_matches

df['server1_first_game_and_match_won'] = df['server1_won'] == 1 & df['server1_first_game_won'] 
server1_first_game_and_match_won = df['server1_first_game_and_match_won'].sum()
A_and_B =  server1_first_game_and_match_won / total_matches


A_given_B = A_and_B / B

A_given_B

# cleanning data

del df['pbp']
del df['winner']
del df['string_servs']

df['totl_servs_qty'] = df['servs_qty']
del df['servs_qty']

df['totl_games_qty'] = df['games_qty']
del df['games_qty']

df['totl_sets_qty'] = df['sets_qty']
del df['sets_qty']

df['player1_won'] =  df['server1_won']
del df['server1_won']

df['player1_lost'] =  df['server1_lost']
del df['server1_lost']

df['player1_first_game_won'] =  df['server1_first_game_won']
del df['server1_first_game_won']

df['player1_first_game_and_match_won'] =  df['server1_first_game_and_match_won']
del df['server1_first_game_and_match_won']

# what is the most common score?
df['score_str'] = [','.join(map(str, l)) for l in df['score']]

df.score_str.value_counts(dropna=False)

# Commented out IPython magic to ensure Python compatibility.
# !pip install brewer2mpl
import numpy as np
import pandas as pd
import matplotlib as mpl
import matplotlib.pyplot as plt
import seaborn as sns
import warnings; warnings.filterwarnings(action='once')

large = 22; med = 16; small = 12
params = {'axes.titlesize': large,
          'legend.fontsize': med,
          'figure.figsize': (16, 10),
          'axes.labelsize': med,
          'axes.titlesize': med,
          'xtick.labelsize': med,
          'ytick.labelsize': med,
          'figure.titlesize': large}
plt.rcParams.update(params)
plt.style.use('seaborn-whitegrid')
sns.set_style("white")
# %matplotlib inline

# Draw Plot
plt.figure(figsize=(16,10), dpi= 80)
# sns.kdeplot(df['servs_qty'], shade=True, color="g", label="Servs qty", alpha=.7)
sns.kdeplot(df['server_won_qty'], shade=True, color="deeppink", label="Server won", alpha=.7)
sns.kdeplot(df['server_ace_qty'], shade=True, color="g", label="Server ace", alpha=.7)
sns.kdeplot(df['server_lost_qty'], shade=True, color="orange", label="Server lost", alpha=.7)
sns.kdeplot(df['server_df_qty'], shade=True, color="dodgerblue", label="Server double fault", alpha=.7)


# Decoration
plt.title('Density Plot of points qty by point type', fontsize=30)
plt.legend()
plt.show()


# Density plots are a commonly used tool visualise the distribution of a continuous variable. 
# By grouping them by the ‘response’ variable, you can inspect the relationship between the X and the Y.
# The below case if for representational purpose to describe how the distribution of city mileage varies with respect the number of cylinders.

# Import Dataset
# df = pd.read_csv("https://github.com/selva86/datasets/raw/master/mtcars.csv")

# Plot
plt.figure(figsize=(12,10), dpi= 80)
sns.heatmap(df.corr(), xticklabels=df.corr().columns, yticklabels=df.corr().columns, cmap='RdYlGn', center=0, annot=True)

# Decorations
# plt.title('Correlogram of mtcars', fontsize=22)
plt.title('Correlogram', fontsize=22)

plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.show()

pip install squarify

import squarify 

# Prepare Data
df_score = df.score_str.value_counts().rename_axis('score').reset_index(name='counts').head(10)
df_score['sob'] = df_score['counts'] / 13050
df_score['sob_format'] = pd.Series(["{0:.2f}%".format(val * 100) for val in df_score['sob']], index = df_score.index)

labels = df_score.apply(lambda x: str(x[0]) + "\n" + str(x[1]) + "\n (" + str(x[3]) + ")", axis=1)
sizes = df_score['counts'].values.tolist()
colors = [plt.cm.Spectral(i/float(len(labels))) for i in range(len(labels))]

# Draw Plot
plt.figure(figsize=(12,8), dpi= 80)
squarify.plot(sizes=sizes, label=labels, color=colors, alpha=.8)

# Decorate
plt.title('Treemap of TOP 10 - Scores')
plt.axis('off')
plt.show()

"""# Sweetviz Analyze"""

# del df['score']
# del df['server1']
# del df['server2']
# del df['pbp']
# del df['set_1']
# del df['string_servs']
# del df['set_1_string']


df

! pip install sweetviz

import sweetviz as sv
import IPython

# list = error

analyze_report = sv.analyze(df)
analyze_report.show_html('analyze.html', open_browser=False)

IPython.display.HTML('analyze.html')



"""# Profiling

The autoreload instruction reloads modules automatically before code execution, which is helpful for the update below.
"""

# Commented out IPython magic to ensure Python compatibility.
# %load_ext autoreload
# %autoreload 2

"""Make sure that we have the latest version of pandas-profiling."""

! pip install https://github.com/pandas-profiling/pandas-profiling/archive/master.zip

import os
os._exit(00)

import pandas as pd
import pandas_profiling
from pandas_profiling import ProfileReport

import sys

!"{sys.executable}" -m pip install -U pandas-profiling[notebook]
!jupyter nbextension enable --py widgetsnbextension

"""You might want to restart the kernel now."""

# Standard Library Imports
from pathlib import Path

# Installed packages
import pandas as pd
from ipywidgets import widgets

# Our package
from pandas_profiling import ProfileReport
from pandas_profiling.utils.cache import cache_file

# Read the Titanic Dataset
# file_name = cache_file(
#     "titanic.csv",
#     "https://raw.githubusercontent.com/datasciencedojo/datasets/master/titanic.csv",
# )


# data_url = '/content/pbp_matches_atp_main_archive.csv'

# df = df
# del df['server1']
# del df['server2']
# del df['pbp']
# del df['score']
# del df['string_servs']
# del df['set_1']
# del df['set_1_string']

df

# Generate the Profiling Report
profile = ProfileReport(
    df, title="Tennis Matches Dataset", html={"style": {"full_width": True}}, sort=None
)

# The Notebook Widgets Interface
profile.to_widgets()

# Or use the HTML report in an iframe
profile

